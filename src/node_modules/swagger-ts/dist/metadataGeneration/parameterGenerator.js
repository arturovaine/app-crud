"use strict";
const metadataGenerator_1 = require('./metadataGenerator');
const resolveType_1 = require('./resolveType');
const ts = require('typescript');
class ParameterGenerator {
    constructor(parameter, method, path) {
        this.parameter = parameter;
        this.method = method;
        this.path = path;
    }
    Generate() {
        const parameterIdentifier = this.parameter.name;
        if (this.path.includes(`{${parameterIdentifier.text}}`)) {
            return this.getPathParameter(this.parameter);
        }
        if (this.supportsBodyParameters(this.method)) {
            try {
                return this.getQueryParameter(this.parameter);
            }
            catch (err) {
                return this.getBodyParameter(this.parameter);
            }
        }
        return this.getQueryParameter(this.parameter);
    }
    getBodyParameter(parameter) {
        const type = resolveType_1.ResolveType(parameter.type);
        const identifier = parameter.name;
        return {
            description: this.getParameterDescription(parameter),
            in: 'body',
            name: identifier.text,
            required: !parameter.questionToken,
            type: type
        };
    }
    getQueryParameter(parameter) {
        const type = resolveType_1.ResolveType(parameter.type);
        const identifier = parameter.name;
        if (!this.isPathableType(type)) {
            throw new Error(`Parameter '${identifier.text}' can't be passed as a query parameter.`);
        }
        return {
            description: this.getParameterDescription(parameter),
            in: 'query',
            name: identifier.text,
            required: !parameter.questionToken,
            type: type
        };
    }
    getPathParameter(parameter) {
        const type = resolveType_1.ResolveType(parameter.type);
        const identifier = parameter.name;
        if (!this.isPathableType(type)) {
            throw new Error(`Parameter '${identifier.text}' can't be passed as a path parameter.`);
        }
        return {
            description: this.getParameterDescription(parameter),
            in: 'path',
            name: identifier.text,
            // TODISCUSS: Path parameters should always be required...right?
            // Apparently express doesn't think so, but I think being able to
            // have combinations of required and optional path params makes behavior
            // pretty confusing to clients
            required: true,
            type: type
        };
    }
    getParameterDescription(node) {
        const symbol = metadataGenerator_1.MetadataGenerator.Current().TypeChecker().getSymbolAtLocation(node.name);
        const comments = symbol.getDocumentationComment();
        if (comments.length) {
            return ts.displayPartsToString(comments);
        }
        return undefined;
    }
    supportsBodyParameters(method) {
        return ['post', 'put', 'patch'].some(m => m === method.toLowerCase());
    }
    isPathableType(parameterType) {
        if (!(typeof parameterType === 'string' || parameterType instanceof String)) {
            return false;
        }
        const type = parameterType;
        return !!['string', 'boolean', 'number'].find(t => t === type);
    }
}
exports.ParameterGenerator = ParameterGenerator;
//# sourceMappingURL=parameterGenerator.js.map