"use strict";
const ts = require('typescript');
const metadataGenerator_1 = require('./metadataGenerator');
const syntaxKindMap = {};
syntaxKindMap[ts.SyntaxKind.NumberKeyword] = 'number';
syntaxKindMap[ts.SyntaxKind.StringKeyword] = 'string';
syntaxKindMap[ts.SyntaxKind.BooleanKeyword] = 'boolean';
syntaxKindMap[ts.SyntaxKind.VoidKeyword] = 'void';
const localReferenceTypeCache = {};
function ResolveType(typeNode) {
    const primitiveType = syntaxKindMap[typeNode.kind];
    if (primitiveType) {
        return primitiveType;
    }
    if (typeNode.kind === ts.SyntaxKind.ArrayType) {
        const arrayType = typeNode;
        return {
            elementType: ResolveType(arrayType.elementType)
        };
    }
    if (typeNode.kind !== ts.SyntaxKind.TypeReference) {
        throw new Error(`Unknown type: ${ts.SyntaxKind[typeNode.kind]}`);
    }
    let typeReference = typeNode;
    if (typeReference.typeName.text === 'Promise') {
        typeReference = typeReference.typeArguments[0];
        return ResolveType(typeReference);
    }
    return generateReferenceType(typeReference.typeName.text);
}
exports.ResolveType = ResolveType;
function generateReferenceType(typeName, cacheReferenceType = true) {
    const existingType = localReferenceTypeCache[typeName];
    if (existingType) {
        return existingType;
    }
    const interfaces = metadataGenerator_1.MetadataGenerator.Current().Nodes()
        .filter(node => {
        if (node.kind !== ts.SyntaxKind.InterfaceDeclaration || !metadataGenerator_1.MetadataGenerator.IsExportedNode(node)) {
            return false;
        }
        return node.name.text.toLowerCase() === typeName.toLowerCase();
    });
    if (!interfaces.length) {
        throw new Error(`No matching model found for referenced type ${typeName}`);
    }
    if (interfaces.length > 1) {
        throw new Error(`Multiple matching models found for referenced type ${typeName}; please make model names unique.`);
    }
    const interfaceDeclaration = interfaces[0];
    const referenceType = {
        description: getModelDescription(interfaceDeclaration),
        name: typeName,
        properties: interfaceDeclaration.members
            .filter(member => member.kind === ts.SyntaxKind.PropertySignature)
            .map((property) => {
            const propertyDeclaration = property;
            const identifier = propertyDeclaration.name;
            return {
                description: getPropertyDescription(propertyDeclaration),
                name: identifier.text,
                required: !property.questionToken,
                type: ResolveType(propertyDeclaration.type)
            };
        })
    };
    const extendedProperties = getExtendedProperties(interfaceDeclaration);
    referenceType.properties = referenceType.properties.concat(extendedProperties);
    if (cacheReferenceType) {
        metadataGenerator_1.MetadataGenerator.Current().AddReferenceType(referenceType);
    }
    localReferenceTypeCache[typeName] = referenceType;
    return referenceType;
}
function getExtendedProperties(interfaceDeclaration) {
    const properties = new Array();
    const heritageClauses = interfaceDeclaration.heritageClauses;
    if (!heritageClauses) {
        return properties;
    }
    heritageClauses.forEach(c => {
        c.types.forEach(t => {
            const baseInterfaceName = t.expression;
            generateReferenceType(baseInterfaceName.text, false).properties
                .forEach(property => properties.push(property));
        });
    });
    return properties;
}
function getModelDescription(interfaceDeclaration) {
    return getNodeDescription(interfaceDeclaration);
}
function getPropertyDescription(propertyDeclaration) {
    return getNodeDescription(propertyDeclaration);
}
function getNodeDescription(node) {
    let symbol = metadataGenerator_1.MetadataGenerator.Current().TypeChecker().getSymbolAtLocation(node.name);
    let comments = symbol.getDocumentationComment();
    if (comments.length) {
        return ts.displayPartsToString(comments);
    }
    return '';
}
//# sourceMappingURL=resolveType.js.map