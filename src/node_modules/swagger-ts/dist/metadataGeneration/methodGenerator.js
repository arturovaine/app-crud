"use strict";
const ts = require('typescript');
const metadataGenerator_1 = require('./metadataGenerator');
const resolveType_1 = require('./resolveType');
const parameterGenerator_1 = require('./parameterGenerator');
class MethodGenerator {
    constructor(node) {
        this.node = node;
        this.processMethodDecorators();
    }
    IsValid() {
        return !!this.method;
    }
    Generate() {
        if (!this.IsValid()) {
            throw new Error('This isn\'t a valid a controller method.');
        }
        if (!this.node.type) {
            throw new Error('Controller methods must have a return type.');
        }
        const identifier = this.node.name;
        return {
            description: this.getMethodDescription(),
            example: this.getMethodExample(),
            method: this.method,
            name: identifier.text,
            parameters: this.getParameters(),
            path: this.path,
            type: resolveType_1.ResolveType(this.node.type)
        };
    }
    getParameters() {
        return this.node.parameters.map(p => {
            return new parameterGenerator_1.ParameterGenerator(p, this.method, this.path).Generate();
        });
    }
    processMethodDecorators() {
        const pathDecorators = this.getDecorators(identifier => {
            return this.getValidMethods().some(m => m.toLowerCase() === identifier.text.toLowerCase());
        });
        if (!pathDecorators.length) {
            return;
        }
        if (pathDecorators.length > 1) {
            throw new Error(`Only one path decorator allowed per method. Found: ${pathDecorators.map(d => d.text).join(', ')}`);
        }
        const decorator = pathDecorators[0];
        const expression = decorator.parent;
        const decoratorArgument = expression.arguments[0];
        this.method = decorator.text.toLowerCase();
        // if you don't pass in a path to the method decorator, we'll just use the base route
        // todo: what if someone has multiple no argument methods of the same type in a single controller?
        // we need to throw an error there
        this.path = decoratorArgument ? `/${decoratorArgument.text}` : '';
    }
    getDecorators(isMatching) {
        const decorators = this.node.decorators;
        if (!decorators || !decorators.length) {
            return;
        }
        return decorators
            .map(d => d.expression)
            .map(e => e.expression)
            .filter(isMatching);
    }
    getValidMethods() {
        return ['get', 'post', 'patch', 'delete', 'put'];
    }
    getMethodDescription() {
        let symbol = metadataGenerator_1.MetadataGenerator.Current().TypeChecker().getSymbolAtLocation(this.node.name);
        let comments = symbol.getDocumentationComment();
        if (comments.length) {
            return ts.displayPartsToString(comments);
        }
        return '';
    }
    // private getMethodParameters() {
    //     let hasBodyParameter = false;
    //     return this.node.parameters.map(p => {
    //         const parameter = new ApiMethodParameter(p, this.path, this.method, hasBodyParameter).getParameter();
    //         if (parameter.in === 'body') { hasBodyParameter = true; }
    //         return parameter;
    //     });
    // }
    // private get200Operation(swaggerType: Swagger.Schema) {
    //     return {
    //         produces: ['application/json'],
    //         responses: {
    //             '200': {
    //                 description: '',
    //                 examples: this.getMethodExample(),
    //                 schema: swaggerType
    //             }
    //         }
    //     };
    // }
    // private get204Operation() {
    //     return {
    //         responses: {
    //             '204': { description: 'No content' }
    //         }
    //     };
    // }
    getMethodExample() {
        const exampleDecorators = this.getDecorators(identifier => identifier.text === 'Example');
        if (!exampleDecorators.length) {
            return undefined;
        }
        if (exampleDecorators.length > 1) {
            throw new Error('Only one Example decorator allowed per controller method.');
        }
        const example = {};
        const decorator = exampleDecorators[0];
        const expression = decorator.parent;
        const argument = expression.arguments[0];
        argument.properties.forEach((p) => {
            example[p.name.text] = this.getInitializerValue(p.initializer);
        });
        return example;
    }
    getInitializerValue(initializer) {
        switch (initializer.kind) {
            case ts.SyntaxKind.ArrayLiteralExpression:
                return initializer.elements.map((e) => this.getInitializerValue(e));
            case ts.SyntaxKind.StringLiteral:
                return initializer.text;
            case ts.SyntaxKind.TrueKeyword:
                return true;
            case ts.SyntaxKind.FalseKeyword:
                return false;
            case ts.SyntaxKind.NumberKeyword:
            case ts.SyntaxKind.FirstLiteralToken:
                return parseInt(initializer.text, 10);
            case ts.SyntaxKind.ObjectLiteralExpression:
                const nestedObject = {};
                initializer.properties.forEach((p) => {
                    nestedObject[p.name.text] = this.getInitializerValue(p.initializer);
                });
                return nestedObject;
            default:
                return undefined;
        }
    }
}
exports.MethodGenerator = MethodGenerator;
//# sourceMappingURL=methodGenerator.js.map