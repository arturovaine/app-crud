"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeProperty = exports.Type = void 0;
const lodash_1 = require("lodash");
class Type {
    constructor(values) {
        if (values) {
            this.fileName = values.fileName;
            this.typeName = values.typeName;
            this.namespace = values.namespace;
            this.fullNamespace = values.fullNamespace;
            this.fullTypeName = values.fullTypeName;
            this.importFile = values.importFile;
            this.isSubType = values.isSubType;
            this.hasSubTypeProperty = values.hasSubTypeProperty;
            this.isBaseType = values.isBaseType;
            this.baseType = values.baseType;
            this.baseImportFile = values.baseImportFile;
            this.path = values.path;
            this.pathToRoot = values.pathToRoot;
            this.properties = values.properties;
        }
    }
    get templateImportTypes() {
        const importTypes = this.properties
            .filter(prop => prop.hasUniqueImportTypes)
            .flatMap(prop => {
            return prop.importTypes.map((item, index) => {
                return { importType: prop.importTypes[index], importFile: prop.importFiles[index] };
            });
        });
        return lodash_1.uniqBy(importTypes, item => item.importType);
    }
    get templateImportEnumTypes() {
        return lodash_1.uniqBy(this.properties
            .filter(prop => prop.isUniqueImportEnumType)
            .map(prop => {
            return { importEnumType: prop.importEnumType };
        }), item => item.importEnumType);
    }
}
exports.Type = Type;
class TypeProperty {
    constructor(values) {
        if (values) {
            this.name = values.name;
            this.staticFieldName = values.staticFieldName;
            this.type = values.type;
            this.typeName = values.typeName;
            this.interfaceTypeName = values.interfaceTypeName;
            this.isUnionType = values.isUnionType;
            this.unionTypeNames = values.unionTypeNames;
            this.unionInterfaceTypeNames = values.unionInterfaceTypeNames;
            this.namespace = values.namespace;
            this.description = values.description;
            this.isComplexType = values.isComplexType;
            this.hasImportTypes = values.hasImportTypes;
            this.hasUniqueImportTypes = values.hasUniqueImportTypes;
            this.importTypes = values.importTypes;
            this.importFiles = values.importFiles;
            this.isEnum = values.isEnum;
            this.enum = values.enum;
            this.isUniqueImportEnumType = values.isUniqueImportEnumType;
            this.importEnumType = values.importEnumType;
            this.isArray = values.isArray;
            this.isArrayComplexType = values.isArrayComplexType;
            this.isArrayUnionType = values.isArrayUnionType;
            this.arrayTypeName = values.arrayTypeName;
            this.arrayInterfaceTypeName = values.arrayInterfaceTypeName;
            this.hasValidation = values.hasValidation;
            this.validators = values.validators;
        }
    }
    get templateTypeNameForInstantiation() {
        if (this.isUnionType && !this.isArray) {
            return lodash_1.first(this.unionTypeNames);
        }
        return this.typeName;
    }
    get templateTypeNameForComplexArray() {
        if (this.isUnionType) {
            return lodash_1.first(this.unionTypeNames);
        }
        return this.arrayTypeName;
    }
    get templateUseInstantiateSubType() {
        var _a;
        if (this.isUnionType) {
            return true;
        }
        if (lodash_1.isArray(this.type)) {
            return lodash_1.some(this.type, item => item.isBaseType);
        }
        return (_a = this.type) === null || _a === void 0 ? void 0 : _a.isBaseType;
    }
}
exports.TypeProperty = TypeProperty;
