"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.logError = exports.log = exports.removeExtension = exports.isInTypesToFilter = exports.getSortedObjectProperties = exports.convertNamespaceToPath = exports.getPathToRoot = exports.removeFolder = exports.getFiles = exports.getDirectories = exports.ensureFolder = exports.ensureFile = exports.writeFileIfContentsIsChanged = exports.readAndCompileTemplateFile = exports.ENCODING = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
const handlebars_1 = require("handlebars");
const moment = require("moment");
const chalk = require("chalk");
const lodash_1 = require("lodash");
exports.ENCODING = 'utf8';
function readAndCompileTemplateFile(templatePath) {
    let templateSource = fs_1.readFileSync(templatePath, exports.ENCODING);
    let template = handlebars_1.compile(templateSource);
    return template;
}
exports.readAndCompileTemplateFile = readAndCompileTemplateFile;
function readFile(outputFileName) {
    let file = fs_1.readFileSync(outputFileName, exports.ENCODING);
    return file;
}
function writeFile(outputFileName, contents) {
    fs_1.writeFileSync(outputFileName, contents, { flag: 'w', encoding: exports.ENCODING });
}
function writeFileIfContentsIsChanged(outputFileName, contents) {
    let isChanged = true;
    if (fs_1.existsSync(outputFileName)) {
        let oldContents = readFile(outputFileName);
        isChanged = oldContents !== contents;
    }
    if (isChanged) {
        writeFile(outputFileName, contents);
    }
    return isChanged;
}
exports.writeFileIfContentsIsChanged = writeFileIfContentsIsChanged;
function ensureFile(outputFileName, contents) {
    ensureFolder(path_1.dirname(outputFileName));
    if (!fs_1.existsSync(outputFileName)) {
        fs_1.writeFileSync(outputFileName, contents, exports.ENCODING);
    }
}
exports.ensureFile = ensureFile;
function ensureFolder(folder) {
    if (!fs_1.existsSync(folder)) {
        fs_1.mkdirSync(folder);
    }
}
exports.ensureFolder = ensureFolder;
function getDirectories(srcpath) {
    return fs_1.readdirSync(srcpath).filter(file => {
        return fs_1.statSync(path_1.join(srcpath, file)).isDirectory();
    });
}
exports.getDirectories = getDirectories;
function getFiles(srcpath) {
    return fs_1.readdirSync(srcpath).filter(file => {
        return fs_1.statSync(path_1.join(srcpath, file)).isFile();
    });
}
exports.getFiles = getFiles;
function removeFolder(folder) {
    if (fs_1.existsSync(folder)) {
        fs_1.readdirSync(folder).forEach((file, index) => {
            let curPath = folder + '/' + file;
            if (fs_1.lstatSync(curPath).isDirectory()) {
                // recurse
                removeFolder(curPath);
            }
            else {
                // delete file
                fs_1.unlinkSync(curPath);
            }
        });
        fs_1.rmdirSync(folder);
    }
}
exports.removeFolder = removeFolder;
function getPathToRoot(namespace) {
    let path = './';
    if (namespace) {
        path = '';
        let namespaceLength = namespace.split('.').length;
        for (let i = 0; i < namespaceLength; ++i) {
            path += '../';
        }
    }
    return path;
}
exports.getPathToRoot = getPathToRoot;
function convertNamespaceToPath(namespace) {
    let parts = namespace.split('.');
    for (let index = 0; index < parts.length; index++) {
        parts[index] = lodash_1.kebabCase(parts[index]);
    }
    let result = parts.join('/');
    // let result = namespace.replace(/\./g, '/');
    return result;
}
exports.convertNamespaceToPath = convertNamespaceToPath;
// export function getTypeFromDescription(description: string) {
//     if (hasTypeFromDescription(description)) {
//         description = description.replace('ts-type', '');
//         return description.replace('type', '').trim();
//     }
//     return description;
// }
// export function hasTypeFromDescription(description: string) {
//     if (description) {
//         return description.startsWith('ts-type') || description.startsWith('type');
//     }
//     return false;
// }
function getSortedObjectProperties(object) {
    const pairs = lodash_1.sortBy(lodash_1.toPairs(object), 0);
    const result = lodash_1.fromPairs(pairs);
    return result;
}
exports.getSortedObjectProperties = getSortedObjectProperties;
function isInTypesToFilter(item, key, options) {
    if (options && options.typesToFilter) {
        const result = !!lodash_1.find(options.typesToFilter, element => {
            return element === key;
        });
        // if (result) {
        //     console.log('item in typesToFilter', key, result);
        // }
        return result;
    }
    return false;
}
exports.isInTypesToFilter = isInTypesToFilter;
function removeExtension(file) {
    return file.replace('.ts', '');
}
exports.removeExtension = removeExtension;
function log(message) {
    let time = moment().format('HH:mm:SS');
    console.log(`[${time}] ${message}`);
}
exports.log = log;
function logError(message) {
    let time = moment().format('HH:mm:SS');
    console.error(`[${time}]`, chalk.red(`*** ERROR *** ${message}`));
}
exports.logError = logError;
