"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateTSFiles = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
const lodash_1 = require("lodash");
const utils_1 = require("./lib/utils");
const model_generator_1 = require("./lib/model-generator");
const enum_generator_1 = require("./lib/enum-generator");
const compile_generated_artifacts_1 = require("./lib/compile-generated-artifacts");
const TEMPLATE_FOLDER = path_1.resolve(__dirname, 'templates');
/**
* Generate TypeScript files based on the given SwaggerFile and some templates
*
* @param {string} swaggerInput The fileName of the swagger.json file including path
* @param {object} options Options which are used during generation
*                 .modelFolder: the name of the folder (path) to generate the models in.
                                each model class is generated in its own file.
*                 .enumTSFile: the name of the enum TS file including path
*                 .enumI18NHtmlFile: the name of the HTML file including path to generate enum values for translation.
*                 .enumLanguageFiles: array with the names of the enum languages file including path
*                 .modelModuleName: the name of the model module (aka namespace)
*                 .enumModuleName: the name of the enum module (aka namespace)
*/
function generateTSFiles(swaggerInput, options) {
    options = enrichConfig(options);
    if (!swaggerInput) {
        throw 'swaggerFileName must be defined';
    }
    if (!lodash_1.isObject(options)) {
        throw 'options must be defined';
    }
    let swagger = typeof swaggerInput === 'string'
        ? JSON.parse(fs_1.readFileSync(swaggerInput, utils_1.ENCODING).trim())
        : swaggerInput;
    if (typeof swagger !== 'object') {
        throw new TypeError('The given swagger input is not of type object');
    }
    // let folder = path.normalize(options.modelFolder);
    // utils.removeFolder(folder);
    model_generator_1.generateModelTSFiles(swagger, options);
    enum_generator_1.generateEnumTSFile(swagger, options);
    if (options.enumI18NHtmlFile) {
        enum_generator_1.generateEnumI18NHtmlFile(swagger, options);
    }
    if (options.enumLanguageFiles) {
        enum_generator_1.generateEnumLanguageFiles(swagger, options);
    }
    compile_generated_artifacts_1.compileGeneratedArtifacts(swagger, options);
}
exports.generateTSFiles = generateTSFiles;
function enrichConfig(options) {
    const templates = options.templates;
    delete options.templates;
    return Object.assign({ generateClasses: true, generateValidatorFile: true, baseModelFileName: 'base-model.ts', validatorsFileName: 'validators.ts', subTypeFactoryFileName: 'sub-type-factory.ts', subTypePropertyName: options.subTypePropertyName || '$type', templates: Object.assign({ validators: `${TEMPLATE_FOLDER}/generate-validators-ts.hbs`, baseModel: `${TEMPLATE_FOLDER}/generate-base-model-ts.hbs`, models: `${TEMPLATE_FOLDER}/generate-model-ts.hbs`, subTypeFactory: `${TEMPLATE_FOLDER}/generate-sub-type-factory-ts.hbs`, enum: `${TEMPLATE_FOLDER}/generate-enum-ts.hbs`, enumLanguage: `${TEMPLATE_FOLDER}/generate-enum-i18n-html.hbs` }, templates) }, options);
}
